#!/usr/bin/env bash
############################
# This is a simple to use shell script that ensures:
# - we always have a fresh image matching our Dockerfile/dckr magic that gets rebuilt only if necessary
# - we always have a container started for that image, with our source mounted, that get restarted only if the image changed
# - we transparently pass any command to be exec-ed inside this container
############################

TERM=${TERM:-}
DOCKERFILE=${DOCKERFILE:-}
TARGET=${TARGET:-}

CONST_DCKR_PREFIX="com.dbdbdp.dckr"

############################
# generic Helpers
############################
DCKR_COLOR_RED=1
DCKR_COLOR_GREEN=2
DCKR_COLOR_YELLOW=3

# Prefix a date to a log line and output to stderr
_dckr_stamp(){
  >&2 printf "[%s] %s\\n" "$(date)" "$*"
}

dckr_logger_info(){
  [[ "$TERM" ]] && [[ -t 2 ]] && >&2 tput setaf "$DCKR_COLOR_GREEN"
  for _i in "$@"; do
    _dckr_stamp "[INFO]" "$_i"
  done
  [[ "$TERM" ]] && [[ -t 2 ]] && >&2 tput op
}

dckr_logger_warning(){
  [[ "$TERM" ]] && [[ -t 2 ]] && >&2 tput setaf "$DCKR_COLOR_YELLOW"
  for _i in "$@"; do
    _dckr_stamp "[WARNING]" "$_i"
  done
  [[ "$TERM" ]] && [[ -t 2 ]] && >&2 tput op
}

dckr_logger_error(){
  [[ "$TERM" ]] && [[ -t 2 ]] && >&2 tput setaf "$DCKR_COLOR_RED"
  for _i in "$@"; do
    _dckr_stamp "[ERROR]" "$_i"
  done
  [[ "$TERM" ]] && [[ -t 2 ]] && >&2 tput op
}

# Check that we have docker
if ! command -v docker >/dev/null; then
  dckr_logger_error "You need to install docker for this to work."
  exit 1
fi

dckr_remove_containers(){
  _ancestor="$1"
  _pth="$2"
  _ex="$(docker ps -qa \
    --filter "ancestor=${CONST_DCKR_PREFIX}:${_ancestor}" \
    --filter "volume=$_pth"
  )"
  if [[ "$_ex" ]]; then
    docker rm -f "$_ex" 1>&2
  fi
}

dckr_has_container(){
  _ancestor="$1"
  _pth="$2"
  _dckr_git="$3"
  _local_git="$4"
  docker ps -q \
    --filter "ancestor=${CONST_DCKR_PREFIX}:${_ancestor}" \
    --filter "volume=$_pth" \
    --filter "label=${CONST_DCKR_PREFIX}.dckr_git=${_dckr_git}" \
    --filter "label=${CONST_DCKR_PREFIX}.local_git=${_local_git}"
}

dckr_run_container(){
  _ancestor="$1"
  _pth="$2"
  _dckr_git="$3"
  _local_git="$4"
  docker run --detach --tty --restart always \
    --volume "$_pth":/project \
    --label="${CONST_DCKR_PREFIX}.dckr_git=${_dckr_git}" \
    --label="${CONST_DCKR_PREFIX}.local_git=${_local_git}" \
    "${CONST_DCKR_PREFIX}:${_ancestor}"
}

docker_remove_image(){
  _ancestor="$1"
  _ex="$(docker images -q "${CONST_DCKR_PREFIX}:${_ancestor}")"
  if [[ "$_ex" ]]; then
    docker rmi -f "$_ex" 1>&2
  fi
}

dckr_has_image(){
  _ancestor="$1"
  _dckr_git="$2"
  _local_git="$3"
  docker images -q "${CONST_DCKR_PREFIX}:${_ancestor}" \
    --filter "label=${CONST_DCKR_PREFIX}.dckr_git=${_dckr_git}" \
    --filter "label=${CONST_DCKR_PREFIX}.local_git=${_local_git}"
}

docker_build_image(){
  _ancestor="$1"
  _target="$2"
  _dckr_git="$3"
  _local_git="$4"
  _dockerfile="$5"
  docker build --target "${_target}" -t "${CONST_DCKR_PREFIX}:${_ancestor}" \
    --label "${CONST_DCKR_PREFIX}.dckr_git=${_dckr_git}" \
    --label "${CONST_DCKR_PREFIX}.local_git=${_local_git}" \
    -f "${_dockerfile}" . 1>&2
}

# Internal
# XXX this is not portable - anyway to make it work for sh? using $0 would fail miserably with the right symlink combination, and readlink on mac is DOA
_here=$(cd "$(dirname "${BASH_SOURCE[0]:-$PWD}")" 2>/dev/null 1>&2 && pwd)

# Allows switching to a different Dockerfile
DCKR_DOCKERFILE="${DOCKERFILE:-$_here/dckr.Dockerfile}"
# Target inside the image
DCKR_TARGET="${TARGET:-ubuntu-lts-current}"

# DCKR hash
DCKR_HASH="$(cat "$_here/dckr" "$_here/dckr.Dockerfile" | shasum -a 256)"
DCKR_HASH=${DCKR_HASH%%  -*}

# Dockerfile hash
DCKR_DOCKERFILE_HASH="$(cat "$DCKR_DOCKERFILE" | shasum -a 256)"
DCKR_DOCKERFILE_HASH=${DCKR_DOCKERFILE_HASH%%  -*}

# Tag hash
tag="$(printf "%s" "$DCKR_TARGET-$DCKR_DOCKERFILE" | shasum -a 256)"
tag="${tag%%  -*}"

# Get a running container
id="$(dckr_has_container "$tag" "$(pwd)" "$DCKR_HASH" "$DCKR_DOCKERFILE_HASH")"

# No running container matching our data?
if [[ ! "$id" ]]; then
  force=

  # Remove existing containers with old hashes
  dckr_remove_containers "$tag" "$(pwd)"

  # Start with our base images
  for i in "alpine-current" "debian-current" "debian-next" "ubuntu-lts-old" "ubuntu-lts-previous" "ubuntu-lts-current"; do
    dckr_logger_info "Checking image $i"
    im=$(dckr_has_image "$i" "$DCKR_HASH" "$DCKR_HASH")
    # If our image is not there
    if [[ ! "$im" ]]; then
      # Remove previous versions
      docker_remove_image "$i"
      # Build it
      docker_build_image "$i" "$i" "$DCKR_HASH" "$DCKR_HASH" "$_here/dckr.Dockerfile"
      # XXX must rebuild the other image as well, because we do not know
      force=true
    fi
  done

  # Now, our target image
  im=$(dckr_has_image "$tag" "$DCKR_HASH" "$DCKR_DOCKERFILE_HASH")
  if [[ ! "$im" ]] || [[ "$force" ]]; then
    # Remove previous versions
    docker_remove_image "$tag"
    # Build it
    docker_build_image "$tag" "$DCKR_TARGET" "$DCKR_HASH" "$DCKR_DOCKERFILE_HASH" "$DCKR_DOCKERFILE"
  fi

  # Now, start the damn container
  id=$(dckr_run_container "$tag" "$(pwd)" "$DCKR_HASH" "$DCKR_DOCKERFILE_HASH")
fi

# Now, we know we have a running container from an up to date image, for sure
# We can now exec the command we were asked to perform
# Caveat: shell expansion happens on the host, unless you get your escaping right...
dckr_logger_info "Running command '$*' inside our running container '${id}'."
docker exec -ti "${id}" "$@"
